<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comodo_'s Splatoon 3 Salmon Run Scale Reward Optimizer</title>
  <!-- Add your CSS links or styles here -->
  <link rel="stylesheet" href="styles.css">
  <style>
  </style>
</head>

<body>
  <header>
    <h1>Comodo_'s Splatoon 3 Salmon Run Scale Reward Optimizer v1</h1>
  </header>

  <main>
    <section>
      <h2>Input Parameters</h2>

      <!-- Input boxes for rank array and time -->
      <label for="rank1">Player 1 Rank:</label>
      <select id="title1">
        <option value=0>Apprentice</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <input type="number" id="rank1" name="rank1" min="0" max="999">
      <label for="noderank1">Prevent Deranking Below: </label>
      <select id="noderank1">
        <option value=0>None</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <br>

      <label for="rank2">Player 2 Rank:</label>
      <select id="title2">
        <option value=0>Apprentice</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <input type="number" id="rank2" name="rank2" min="0" max="999">
      <label for="noderank2">Prevent Deranking Below: </label>
      <select id="noderank2">
        <option value=0>None</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <br>

      <label for="rank3">Player 3 Rank:</label>
      <select id="title3">
        <option value=0>Apprentice</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <input type="number" id="rank3" name="rank3" min="0" max="999">
      <label for="noderank3">Prevent Deranking Below: </label>
      <select id="noderank3">
        <option value=0>None</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <br>

      <label for="rank4">Player 4 Rank:</label>
      <select id="title4">
        <option value=0>Apprentice</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <input type="number" id="rank4" name="rank4" min="0" max="999">
      <label for="noderank4">Prevent Deranking Below: </label>
      <select id="noderank4">
        <option value=0>None</option>
        <option value=1>Part-Timer</option>
        <option value=2>Go-Getter</option>
        <option value=3>Overachiever</option>
        <option value=4>Profreshional</option>
        <option value=5>Profreshional +1</option>
        <option value=6>Profreshional +2</option>
        <option value=7>Profreshional +3</option>
        <option value=8>Eggsecutive VP</option>
      </select>
      <br>

      <label for="time">Desired Reward:</label>
      <select id="dropdown">
        <option value=0>Bronze Scales</option>
        <option value=1>Silver Scales</option>
        <option value=2>Gold Scales</option>
        <option value=3>Boss Encounters</option>
      </select>
      <br>

      <form>
        <input type="radio" id="button1" name="buttons" value="fixedCount">
        <label for="button1">Optimize For Fixed Quantity: </label>
        <input type="count" id="count" name="count" min="0"><br>
        <input type="radio" id="button2" name="buttons" value="fixedTime">
        <label for="button2">Optimize For Fixed Time (hours): </label>
        <input type="number" id="time" name="time" min="0"><br>
      </form>

      <label for="simcount">Simulation Count (Lower = Less Accuracy, Higher = Slower Calculation)</label>
      <input type="number" id="simcount" name="simcount" min="0" max="10000000">
      <br>


      <!-- Button to trigger the script -->
      <button onclick="runScript()">Calculate Optimal Output</button>

      <!-- Output section -->
      <div id="output">
        <textarea id="outputTextarea" readonly></textarea>
      </div>
    </section>
  </main>

  <footer>
    <!-- Add your footer content here -->
    <p></p>
  </footer>

  <!-- Add your JavaScript links or scripts here -->
  <script>

    /*|||||||||||||||||||||||
    |||OUTPUT DOCUMENTATION||
    |||||||||||||||||||||||*/

    /*
      Calculated results are stored in the array 'allResults'. The array has a size of 6, with indexes 0-5 representing each possible number of thrown games, sorted by descending desired reward if fixed time is chosen, and ascending time if fixed quanitity is chosen. The parameters are as follows:

     - Identifying Data
      allResults[].throwCount = number of games thrown
      allResults[].time = (fixed quantity only) the average time to reach desired quantity
     
      
      - Data Values (each one has a this.avg, this.std, this.max, and this.min for average, std deviation, max, and min respectively)
      allResults[].bossTime = time between bosses
      allResults[].bosses = number of bosses fought
      allResults[].scales = contains avg[], std[], max[], and min[] arrays for data on each scale type
      allResults[].hazard = hazard at which bosses are fought
      allResults[].rankChange = change in rank between bosses
      allResults[].finalRanks[] = an array, each with a this.avg, etc. value containing data on the final ranks of each player (0-1799). Sorry that this isn't consistent with the way the scales work i'll fix it if i have the time ;(
      allResults[].derankData = if a player is to derank below the user inputted rank on average, this will contain data on the time which that happens, as well as a this.player variable which contains the index of the player set to derank first (-1 if none)

      - NOTE: NOT ALL DATA VALUES WILL BE CALCULATED IF FIXED QUANITITY IS SELECTED AND A PLAYER IS TO DERANK BELOW USER SELECTED THRESHOLD ON AVERAGE BEFORE REACHING DESIRED QUANTITY FOR THAT THROWCOUNT
    */


    /*||||||||||
    |||CLASSES||
    ||||||||||*/

    // class for storing necessary info if a player will derank on average within the chosen time
    class DerankData {
      constructor(player, avg, std, max, min) {

        // the player who is to derank (0-3, -1 if none)
        this.player = player;

        // the data on the time it takes for them to derank (the total time of the session gets capped to the avg value if it exceeds the maximum time inputted by the user)
        this.avg = avg;
        this.std = std;
        this.max = max;
        this.min = min;
      }
    }

    // class for storing average and standard deviation of data values
    class DataValue {
      constructor(avg, std, max, min) {
        // average, standard deviation, max, min
        this.avg = avg;
        this.std = std;
        this.max = max;
        this.min = min;
      }
    }

    // class for storing all info on rewards
    // once calculated, the sets of result data are stored allResults[] in descending order of desiredType
    class ResultData {
      constructor() {

        // data values, all of class DataValue
        this.bossTime;
        this.bosses;
        this.scales;
        this.hazard;
        this.rankChange;

        this.finalRanks;


        // derank data, of class DerankData
        this.derankData;

        // identifying data
        this.throwCount;
        this.time;
      }
    }

    /*||||||||||
    ||FUNCTIONS|
    ||||||||||*/

    // FUNCTION: average rank change between boss encounters
    function getRankChange(throwCount) {

      // calculate average and standard variance of smell upon fighting a boss
      let probabilities = [0, 0, 0.1, 0.3, 0.6, 1]; // Cumulative distribution function (CDF)
      let averageRolls = 0; // Expected value (average)
      let variance = 0; // Variance

      // zero out probabilities to account for skipped rolls due to throwCount
      if (throwCount != 0) {
        for (let j = throwCount - 1; j >= 0; j--) {
          probabilities[j] = 0
        }
      }

      // Loop over all possible outcomes
      for (let i = 0; i < probabilities.length; i++) {
        // Calculate the probability of outcome `i`
        let probability = probabilities[i] - (probabilities[i - 1] || 0);

        // Add `i * probability` to the expected value
        averageRolls += i * probability;

        // Add `i * i * probability` to the variance
        variance += i * i * probability;
      }

      variance -= averageRolls * averageRolls;

      let standardDeviation = Math.sqrt(variance);



      // convert smell upon fighting boss into change in rank
      // smell + 1 - throwCount gives games won
      let avg = smellToRank(averageRolls, throwCount);

      let std = standardDeviation * 20;

      let max = smellToRank(5, throwCount);

      let min = smellToRank(throwCount, throwCount);


      // return final results
      return new DataValue(avg, std, max, min);
    }


    // FUNCTION: Converts smell for boss encounter to change in rank given throwCount
    function smellToRank(smell, throwCount) {
      // rank changes per wave lost at
      let waveLoss = 20;
      // points lost
      let pointsLost = throwCount * waveLoss;

      // points won
      let pointsWon = ((smell - throwCount) * 20) + 20;


      // return change in rank
      return pointsWon - pointsLost;
    }


    // FUNCTION: average time between bosses
    function getTime(throwCount) {
      //array of the time for a throw depending on what wave you throw on
      let throwMatchTime = 58;
      // time for a full match
      let winMatchTime = 421;
      // additional time for a boss
      let bossTime = 125;

      // calculate average total time on thrown matches
      let totalThrowTime = (throwCount * throwMatchTime);

      // get rank change data
      let rankChangeData = getRankChange(throwCount);

      //calculate average total time on won matches
      let avgTotalWinTime = ((rankChangeData.avg + (20.0 * throwCount)) / 20.0) * winMatchTime;

      // calculate standard deviation of avgTotalWinTime
      let stdTotalWinTime = ((rankChangeData.std + (20.0 * throwCount)) / 20.0) * winMatchTime;


      let maxTotalWinTime = ((rankChangeData.max + (20.0 * throwCount)) / 20.0) * winMatchTime;

      let minTotalWinTime = ((rankChangeData.min + (20.0 * throwCount)) / 20.0) * winMatchTime;

      // add together along with boss time for average total time
      let avg = totalThrowTime + avgTotalWinTime + bossTime;

      // calculate standard deviation
      let std = stdTotalWinTime;

      // calculate max
      let max = totalThrowTime + maxTotalWinTime + bossTime;

      // calculate min
      let min = totalThrowTime + minTotalWinTime + bossTime;


      return new DataValue(avg, std, max, min);
    }


    // FUNCTION: scales given hazard
    function getScales(hazard, bosses) {
      let scaleNum = 10;
      // calculate average and standard deviation of probabilities
      let pAvg = [
        1 - ((0.05 + 0.05 * hazard.avg / 111) + (0.01 * hazard.avg / 111)), // bronze
        (0.05 + 0.05 * hazard.avg / 111), // silver
        (0.01 * hazard.avg / 111) // gold
      ];
      let pStd = [
        1 - ((0.05 + 0.05 * hazard.std / 111) + (0.01 * hazard.std / 111)), // bronze
        (0.05 + 0.05 * hazard.std / 111), // silver
        (0.01 * hazard.std / 111) // gold
      ];

      // calculate average and standard deviation of scale output
      let avg = [pAvg[0] * scaleNum * bosses.avg, pAvg[1] * scaleNum * bosses.avg, pAvg[2] * scaleNum * bosses.avg];
      let std = [pStd[0] * scaleNum * bosses.std, pStd[1] * scaleNum * bosses.std, pStd[2] * scaleNum * bosses.std];

      let max = [Math.trunc(scaleNum * bosses.avg), Math.trunc(scaleNum * bosses.avg), Math.trunc(scaleNum * bosses.avg)];
      let min = [0, 0, 0];

      return new DataValue(avg, std, max, min);
    }


    // FUNCTION: average boss encounters given time and DataValue 'time'
    function getBosses(time, bossDuration) {

      // just divide time by the length of each boss cycle lol
      let avg = time / bossDuration.avg;
      let std = time / bossDuration.std;
      let max = Math.trunc(time / bossDuration.min);
      let min = Math.trunc(time / bossDuration.max);

      return new DataValue(avg, std, max, min);
    }


    // FUNCTION: average final given ranks, boss encounters, and change per boss encounter
    function getFinalRanks(startRankArray, mean, stdDev, max, min, numEncounters, numSimulations) {
      let allPlayerStats = [];

      for (let j = 0; j < startRankArray.length; j++) {
        let startRank = startRankArray[j];
        let finalRanks = [];

        for (let s = 0; s < numSimulations; s++) {
          let playerRank = startRank;

          for (let i = 0; i < numEncounters; i++) {
            // Simulate change in playerRank using Box-Muller transform for normal distribution
            let u = Math.random();
            let v = Math.random();
            let change = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * stdDev + mean;
            change = Math.max(min, Math.min(max, change)); // Ensure change is within min and max
            let newRank = playerRank + change;

            // Adjust rank based on thresholds
            if (newRank < 0) {
              playerRank = 0;
            } else if (newRank > 1799) {
              playerRank = 1799;
            } else {
              if (newRank < playerRank && newRank < 800) {
                let threshold = Math.floor(playerRank / 100) * 100;
                if (newRank < threshold) {
                  playerRank = threshold - 60;
                } else {
                  playerRank = newRank;
                }
              } else if (newRank > playerRank && newRank < 900) {
                let threshold = Math.ceil(playerRank / 100) * 100;
                if (newRank > (threshold + 100)) {
                  playerRank = threshold + 40;
                }
                else {
                  playerRank = newRank;
                }
              } else {
                playerRank = newRank;
              }
              playerRank = Math.max(0, Math.min(1799, playerRank));
            }
          }

          // After all encounters, push the final rank to finalRanks
          finalRanks.push(playerRank);
        }

        // After all simulations, calculate the average, standard deviation, max, and min of finalRanks
        let totalRank = finalRanks.reduce((a, b) => a + b, 0);
        let avg = totalRank / numSimulations;
        let std = Math.sqrt(finalRanks.map(x => Math.pow(x - avg, 2)).reduce((a, b) => a + b) / numSimulations);
        let maxRank = Math.max(...finalRanks);
        let minRank = Math.min(...finalRanks);

        // Push the player's stats to allPlayerStats
        allPlayerStats.push(new DataValue(avg, std, maxRank, minRank));
      }

      return allPlayerStats;
    }





    // FUNCTION: bruteforce overall hazard of a player given startingRank, mean of rank change, stddev of rank change, max, and min
    function getHazard(startRankArray, mean, stdDev, max, min, numEncounters, simCount) {
      let avgArray = [];
      let stdArray = [];
      let maxHazardArray = [];
      let minHazardArray = [];

      for (let j = 0; j < startRankArray.length; j++) {
        let startRank = startRankArray[j];
        let totalHazard = 0;
        let hazardArray = [];
        let averageHazardArray = [];

        for (let sim = 0; sim < simCount; sim++) {
          let playerRank = startRank;

          for (let i = 0; i < numEncounters; i++) {
            // Simulate change in playerRank using Box-Muller transform for normal distribution
            let u = Math.random();
            let v = Math.random();
            let change = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * stdDev + mean;
            change = Math.max(min, Math.min(max, change)); // Ensure change is within min and max
            let newRank = playerRank + change;

            // Adjust rank based on thresholds
            if (newRank < 0) {
              playerRank = 0;
            } else if (newRank > 1799) {
              playerRank = 1799;
            } else {
              if (newRank < playerRank && newRank < 800) {
                let threshold = Math.floor(playerRank / 100) * 100;
                if (newRank < threshold) {
                  playerRank = threshold - 60;
                } else {
                  playerRank = newRank;
                }
              } else if (newRank > playerRank && newRank < 900) {
                let threshold = Math.ceil(playerRank / 100) * 100;
                if (newRank > (threshold + 100)) {
                  playerRank = threshold + 40;
                }
                else {
                  playerRank = newRank;
                }
              } else {
                playerRank = newRank;
              }
              playerRank = Math.max(0, Math.min(1799, playerRank));
            }

            // Ensure playerRank is within 0 and 1799
            playerRank = Math.max(0, Math.min(1799, playerRank));

            // Calculate hazard
            let hazard = playerRank < 1665 ? playerRank * 0.2 : 333;
            totalHazard += hazard;
            hazardArray.push(hazard);
            averageHazardArray.push(totalHazard / (i + 1));
          }
        }

        let avg = totalHazard / (numEncounters * simCount);
        let std = Math.sqrt(hazardArray.map(x => Math.pow(x - avg, 2)).reduce((a, b) => a + b) / (numEncounters * simCount));
        let maxHazard = Math.max(...hazardArray);
        let minHazard = Math.min(...hazardArray);

        avgArray.push(avg);
        stdArray.push(std);
        maxHazardArray.push(maxHazard);
        minHazardArray.push(minHazard);
      }

      let avgOfAvg = avgArray.reduce((a, b) => a + b) / avgArray.length;
      let stdOfAvg = Math.sqrt(avgArray.map(x => Math.pow(x - avgOfAvg, 2)).reduce((a, b) => a + b) / avgArray.length);
      let maxOfAvg = Math.max(...avgArray);
      let minOfAvg = Math.min(...avgArray);

      return new DataValue(avgOfAvg, stdOfAvg, maxOfAvg, minOfAvg);
    }



    // FUNCTION: checks if any player is to reach a derank within the given time, returns DerankData
    function checkDerank(initialRank, results, inputDerank) {
      //assign variables for necessary values


      // initialize variables
      let derankPlayer = -1;
      let timeAvg = 0.0;
      let timeStd = 0.0;
      let timeMax = 0.0;
      let timeMin = 0.0;
      let derankChance = 0.0;
      let derankDistance = [0, 0, 0, 0];

      // find player with lowest rank before hitting threshhold
      let lowestRank = Number.MAX_VALUE;
      let lowestPlayer = -1;
      for (let i = 0; i < 4; i++) {
        // if inputDerank is set
        if (inputDerank[i] > 0) {
          // calculate how far from derank
          if (initialRank[i] >= 800) {
            derankDistance[i] = initialRank[i] - 800;
          } else {
            derankDistance[i] = (((Math.floor(initialRank[i] / 100)) - (inputDerank[i] / 100) * 40) + (initialRank[i] % 100));
          }

          // if closer than the closest rank
          if (derankDistance[i] < lowestRank) {
            // update closest rank
            lowestPlayer = i;
            lowestRank - derankDistance[i];
          }
        }
      }
      // check if any players actually set the flag
      if (lowestPlayer > -1) {
        // if the lower ranked player goes below 0 on average
        if (results.finalRanks[lowestPlayer].avg < (inputDerank[lowestPlayer] * 100)) {
          // store player index
          derankPlayer = lowestPlayer;
          // calculate the time at which the player will reach 0 rank
          timeAvg = ((derankDistance[lowestPlayer] / (-results.rankChange.avg)) * results.bossTime.avg);
          timeStd = ((derankDistance[lowestPlayer] / (-results.rankChange.avg)) * results.bossTime.std);
          timeMax = ((derankDistance[lowestPlayer] / (-results.rankChange.avg)) * results.bossTime.max);
          timeMin = ((derankDistance[lowestPlayer] / (-results.rankChange.avg)) * results.bossTime.min);
        }
      }
      // return data
      return new DerankData(derankPlayer, timeAvg, timeStd, timeMax, timeMin);
    }


    // FUNCTION: calculates all result data given initial ranks, throwCount
    function getResults(initialRanks, time, throwCount, desiredType, inputDerank, simCount) {


      // create new ResultData object to store results in
      let results = new ResultData();


      // assign identifying data
      results.throwCount = throwCount;


      // if given time is to be used

      // use given time
      results.time = time;


      // calculate data for checkDerank
      results.rankChange = getRankChange(throwCount);
      results.bossTime = getTime(throwCount);
      results.bosses = getBosses(results.time, results.bossTime);
      results.finalRanks = getFinalRanks(initialRanks, results.rankChange.avg, results.rankChange.std, results.rankChange.max, results.rankChange.min, Math.max(1, Math.round(results.bosses.avg)), simCount);

      // get derank data
      results.derankData = checkDerank(initialRanks, results, inputDerank);



      // if there is a derank on average
      if (results.derankData.avg < results.time && results.derankData.player != -1) {
        // update time to match new time (THIS MEANS ALL RESULTS WILL BE BASED ON THE AVERAGE MAXIMUM PLAY TIME)
        results.time = results.derankData.avg;

        // recalculate time dependent data
        results.rankChange = getRankChange(throwCount);
        results.bossTime = getTime(throwCount);
        results.bosses = getBosses(results.time, results.bossTime);
        results.finalRanks = getFinalRanks(initialRanks, results.rankChange.avg, results.rankChange.std, results.rankChange.max, results.rankChange.min, Math.max(1, Math.round(results.bosses.avg)), simCount);
      }

      // calculate remaining data
      results.hazard = getHazard(initialRanks, results.rankChange.avg, results.rankChange.std, results.rankChange.max, results.rankChange.min, Math.max(1, Math.round(results.bosses.avg)), simCount);
      results.scales = getScales(results.hazard, results.bosses);


      // return results
      return results;

    }

    // FUNCTION: prints results to console
    function debugPrint(results) {
      console.log("throw: " + results.throwCount);
      console.log("time: " + results.time);
      console.log("bosstime: " + results.bossTime.avg + " std: " + results.bossTime.std + " max: " + results.bossTime.max + " min: " + results.bossTime.min);
      console.log("rankchange: " + results.rankChange.avg + " std: " + results.rankChange.std + " max: " + results.rankChange.max + " min: " + results.rankChange.min);
      console.log("bosses: " + results.bosses.avg + " std: " + results.bosses.std + " max: " + results.bosses.max + " min: " + results.bosses.min);
      console.log("scales: " + results.scales.avg + " std: " + results.scales.std + " max: " + results.scales.max + " min: " + results.scales.min);
      console.log("final ranks: " + results.finalRanks);
      console.log("hazard: " + results.hazard.avg + " std: " + results.hazard.std + " max: " + results.hazard.max + " min: " + results.hazard.min);
      console.log("derank player: " + results.derankData.player);
      console.log("derank: " + results.derankData.avg + " std: " + results.derankData.std + " max: " + results.derankData.max + " min: " + results.derankData.min);
    }


    // FUNCTION: sorts results from highest to lowest
    function insertionSort(arr, compare) {
      for (let i = 1; i < arr.length; i++) {
        let current = arr[i];
        let j = i - 1;
        while (j >= 0 && compare(arr[j], current) < 0) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = current;
      }
      return arr;
    }





    // FUNCTION: sorts results from lowest to highest
    function ascInsertionSort(arr, compare) {
      for (let i = 1; i < arr.length; i++) {
        let current = arr[i];
        let j = i - 1;
        while (j >= 0 && compare(arr[j], current) > 0) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = current;
      }
      return arr;
    }





    // FUNCTION: compares a property between two objects of the same Class
    function compareByProperty(a, b, property, index) {
      // Split the property string into an array of properties
      let properties = property.split('.');

      // Use reduce to navigate through the properties
      let aValue = properties.reduce((obj, prop) => obj[prop], a);
      let bValue = properties.reduce((obj, prop) => obj[prop], b);

      // If an index is provided, use it
      if (index !== undefined) {
        aValue = aValue[index];
        bValue = bValue[index];
      }

      // Compare the values
      if (aValue < bValue) {
        return -1;
      }
      if (aValue > bValue) {
        return 1;
      }
      return 0;
    }


    // FUNCTION: converts title id to name
    function titleToName(titleID) {
      switch (titleID) {
        case 0:
          return "Apprentice";
        case 1:
          return "Part-Timer";
        case 2:
          return "Go-Getter";
        case 3:
          return "Overacheiver";
        case 4:
          return "Profreshional";
        case 5:
          return "Profreshional +1";
        case 6:
          return "Profreshional +2";
        case 7:
          return "Profreshional +3";
        case 8:
          return "Eggsecutive VP";
      }
      return;
    }

    function typeToName(typeID) {
      switch (Number(typeID)) {
        case 0:
          return "Bronze Scales";
        case 1:
          return "Silver Scales";
        case 2:
          return "Gold Scales";
        case 3:
          return "Boss Encounters";
      }
      return;
    }

    // FUNCTION: Returns a ResultsData object with the lowest time for the desiredCount of desiredType given throwCount and initialRanks
    function getFixed(initialRanks, throwCount, desiredType, desiredCount, inputDerank, simCount) {
      let lower = 0;
      let upper = 1;
      let callStackLimit = 3546000;
      let tempResults = new DataValue();

      if (desiredType == 3) {
        // BOSSES

        //Double the upper bound until the result is above the desired value
        while (upper < callStackLimit) {
          tempResults = getResults(initialRanks, upper, throwCount, desiredType, inputDerank, simCount);
          if (tempResults.bosses.avg >= desiredCount) {
            break;
          }
          upper *= 2;
          console.log(tempResults.bosses.avg)
          console.log(desiredCount);
        }

        // Perform a binary search from the current lower and upper bounds
        while (lower < upper) {
          let middle = (lower + upper) / 2;
          tempResults = getResults(initialRanks, middle, throwCount, desiredType, inputDerank, simCount);
          if (tempResults.bosses.avg >= desiredCount) {
            upper = middle;
          } else {
            lower = middle + 1;
          }
        }
      } else {
        // SCALES 

        //Double the upper bound until the result is above the desired value
        while (upper < callStackLimit) {
          tempResults = getResults(initialRanks, upper, throwCount, desiredType, inputDerank, simCount);
          if (tempResults.scales.avg[desiredType] >= desiredCount) {
            break;
          }
          upper *= 2;
          console.log(tempResults.scales.avg[desiredType])
          console.log(upper);
        }
        if (upper > callStackLimit) {
          callStackFlag = 1;
        }

        // Perform a binary search from the current lower and upper bounds
        while (lower < upper) {
          let middle = (lower + upper) / 2;
          tempResults = getResults(initialRanks, middle, throwCount, desiredType, inputDerank, simCount);
          if (tempResults.scales.avg[desiredType] >= desiredCount) {
            upper = middle;
          } else {
            lower = middle + 1;
          }
        }
      }

      // Return the optimal result data
      return tempResults;
    }
    /*||||||||||
    ||||MAIN||||
    ||||||||||*/


    function runScript() {
      //|||||||||||||||||||||||||||||||||||||||||||||||||||||||
      // USER VARIABLES

      // player ranks
      const inputRank = [0, 0, 0, 0];
      inputRank[0] = parseInt(document.getElementById("rank1").value);
      inputRank[1] = parseInt(document.getElementById("rank2").value);
      inputRank[2] = parseInt(document.getElementById("rank3").value);
      inputRank[3] = parseInt(document.getElementById("rank4").value);
      // player titles
      const inputTitle = [0, 0, 0, 0];
      inputTitle[0] = document.getElementById("title1").value;
      inputTitle[1] = document.getElementById("title2").value;
      inputTitle[2] = document.getElementById("title3").value;
      inputTitle[3] = document.getElementById("title4").value;
      // player derank title
      const inputDerank = [0, 0, 0, 0];
      inputDerank[0] = document.getElementById("noderank1").value;
      inputDerank[1] = document.getElementById("noderank2").value;
      inputDerank[2] = document.getElementById("noderank3").value;
      inputDerank[3] = document.getElementById("noderank4").value;

      const hours = parseFloat(document.getElementById("time").value);
      // used to store entered time in seconds if desiredCount == 0
      const time = hours * 3600;

      // desired scale type
      var selectElement = document.getElementById('dropdown');
      var desiredType = selectElement.value;
      selectElement.addEventListener('change', function () {
        desiredType = this.value;
      });

      // number of simulations
      const simCount = parseInt(document.getElementById("simcount").value);

      // Fixed Quantity / Fixed Time
      // desiredCount == 0: optimize for max count with time given
      // !0: optimize for min time with desiredCount given
      var desiredCount = parseInt(document.getElementById("count").value);
      var buttons = document.getElementsByName('buttons');

      const ranks = [0, 0, 0, 0];
      // merge player title into player rank
      for (let i = 0; i < 4; i++) {
        // multiply inputTitle by 100 and add inputRank to get true rank from 0-1799
        ranks[i] = (inputTitle[i] * 100) + inputRank[i];
      }
      // Output section
      let outputText = '';

      // variable for results
      let allResults = [];

      var selectedValue;
      for (var i = 0; i < buttons.length; i++) {
        if (buttons[i].checked) {
          selectedValue = buttons[i].value; // if this radio button is checked, get its value
          break; // exit the loop as we've found the selected button
        }
      }

      // END OF USER VARIABLES
      //|||||||||||||||||||||||||||||||||||||||||||||||||||||||


      // if no button is checked, throw an error
      if (selectedValue == undefined) {
        document.getElementById("outputTextarea").value = `Please Choose Between Fixed Quantity And Fixed Time.`;
      } else if (selectedValue == "fixedCount") {
        // fixed quantity

        // calculate all results
        for (let count = 0; count < 6; count++) {
          allResults[count] = getFixed(ranks, count, desiredType, desiredCount, inputDerank, simCount);
          debugPrint(allResults[count]);
          allResults = ascInsertionSort(allResults, (a, b) => compareByProperty(a, b, 'time'));
        }
      } else {

        // fixed time
        // calculate all results
        for (let count = 0; count < 6; count++) {
          // duplicate variable for adjusting if bosses is chosen
          let searchDesiredType = desiredType;
          // if bosses was chosen
          if (desiredType == 3) {
            // adjust to just search for bronze scales
            searchDesiredType = 0;
          }
          allResults[count] = getResults(ranks, time, count, desiredType, inputDerank, simCount);
          debugPrint(allResults[count]);
          allResults = insertionSort(allResults, (a, b) => compareByProperty(a, b, 'scales.avg', searchDesiredType));
        }
      }





      // check if derank occured
      if (allResults[0].derankData.player != -1) {
        outputText += `Player ${allResults[0].derankData.player} will drop below ${inputDerank[allResults[0].derankData.player]} 0 at an average time of ${(allResults[0].derankData.avg / 3600)} hours.Following results use this as the average play time.\n`;
      }

      // change desiredType ID to string
      let desiredTypeString = typeToName(desiredType);

      // Print results dependent on if fixed quantity or time was chosen
      if (selectedValue == "fixedCount") {
        if (desiredType == 3) {
          // if we hit the time limit
          if (allResults[0].bosses.avg < (desiredCount - 1)) {
            outputText += `Warning: maximum time exceeded.\n`;
            desiredCount = allResults[0].bosses.avg;
          }
        } else {
          // if we hit the time limit
          if (allResults[0].scales.avg[desiredType] < (desiredCount - 1)) {
            outputText += `Warning: maximum time exceeded.\n`;
            desiredCount = allResults[0].scales.avg[desiredType];
          }
        }
        outputText += `Minimum of ${(allResults[0].time / 3600)} hours required for ${desiredCount} ${desiredTypeString}\n`;
      } else {
        outputText += `Optimal ${desiredTypeString} for play session of ${(time / 3600)} hours: \n`;
      }

      // print optimal results
      outputText += `Optimal throw count: ${allResults[0].throwCount} \n`;
      outputText += `Boss encounters: ${allResults[0].bosses.avg} \n`;
      outputText += `Bronze: ${allResults[0].scales.avg[0]} \n`;
      outputText += `Silver: ${allResults[0].scales.avg[1]} \n`;
      outputText += `Gold: ${allResults[0].scales.avg[2]} \n`;
      outputText += `Hazard of Bosses: ${allResults[0].hazard.avg} \n`;
      outputText += `Rank Change Between Bosses: ${allResults[0].rankChange.avg} \n`;

      let playerFinalRankTitles = ["", "", "", ""];
      let playerFinalRankRemainder = [0, 0, 0, 0];
      for (let i = 0; i < 4; i++) {
        if (allResults[0].finalRanks[i].avg >= 800) {
          playerFinalRankRemainder[i] = allResults[0].finalRanks[i].avg - 800;
          playerFinalRankTitles[i] = "Eggsecutive VP";
        } else {
          let id = Math.floor(allResults[0].finalRanks[i].avg / 100)
          playerFinalRankRemainder[i] = allResults[0].finalRanks[i].avg - (100 * id);
          playerFinalRankTitles[i] = titleToName(id);
        }
      }
      outputText += `Final Rank of Player 1: ${playerFinalRankTitles[0]} ${playerFinalRankRemainder[0]} \n`;
      outputText += `Final Rank of Player 2: ${playerFinalRankTitles[1]} ${playerFinalRankRemainder[1]} \n`;
      outputText += `Final Rank of Player 3: ${playerFinalRankTitles[2]} ${playerFinalRankRemainder[2]} \n`;
      outputText += `Final Rank of Player 4: ${playerFinalRankTitles[3]} ${playerFinalRankRemainder[3]} \n`;

      // Display the output in the textarea
      document.getElementById("outputTextarea").value = outputText;
    }
  </script>
</body>

</html>
